Introduction to go
and its concurrency primatives
17 Feb 2015

Ben Bariteau
bariteau@yelp.com

* What go has

- concurrency
- garbage collection
- objects (after a fashion)
- multiple return types
- interfaces
- first-class functions
- runtime reflection


* What go does not have

- polymorphic inheritance
- generic types
- semicolons


* Hello world

.play hello_world.go


* Basics


* Variable declaration

all of these do the same thing

    var foo int
    var foo = 0
    foo := 0


* Other types

strings

    baz := "" // zero value
    bam := "Big Data"

bool

    goIsCool := true
    goSucks := false // zero value

(u|)int(8|16|32|64)

    i := 0 // defaults to int
    var j int32 = 42
    k := i + j // compile error, not the same type!

    var m uint8 = 255
    var n int8 = 255 // compile eror, int8 won't fit that value!


* Functions

simplest function, no parameters, returns nothing

    func main()

takes a string and a bool, returns an int

    func frobinate(foo string, bar bool) int

this func takes two strings and returns a int and a bool

    func refrobinate(foo, bar string) (int, bool)


* Slices and arrays

arrays have fixed length (like C or Java)

.play array_acess.go /START OMIT/,/END OMIT

slices are kind of like python lists

    // these have the same effect
    slice := make([]string, 0)
    var slice []string // an uninitalized slice acts like an empty slice

* Fun with slices

slices have a length and a capacity (defined by the underlying array)

.play slice_len_cap.go /START OMIT/,/END OMIT/

slices can be assigned past their length, as long as there is capacity

    bar := make([]string, 0, 10)
    bar[9] = "Jean-Luc Picard"

built in append function allows for appending to a slice
    
    foo := make([]int, 0)
    foo = append(foo, 47)


* Maps

unlike slices, maps must be created

    tngEpisodes := make(map[string]int)

they work a lot like defaultdicts in python

    tngEpisodes["Darmok"] = 102
    i := tngEpisodes["Darmok"] // i now contains 102!
    j := tngEpisodes["The Visitor"] // j now contains 0

if you need to know if the key is in the map

    k, ok := tngEpisodes["Encounter at Farpoint"]

* Advanced types

* Type declarations

    type myInt int

    type thing episode {
        title  string
        number int
    }

* Methods

.play stringer.go

* Interfaces
    package fmt
    
    ...

    type Stringer interface {
        String() string
    }

shortens the last example to

    var i myInt = 47
    fmt.Print(i)

* The error type

    type Error interface {
        Error() string
    }

often the second return value of a function

    func main() {
        fd, err := io.Open("path/to/file") 
        if err != nil {
            fmt.Print(err) 
            os.Exit(1)
        }
        // do something with the file
    }

* Control structures

* The if statement

    func compare(a, b int) int {
        if a > b {
            return 1
        } else if a < b {
            return -1
        } else {
            return 0
        }
    }

optional initalization

    if powerLevel := getPowerLevel(); powerLevel > 9000 {
        fmt.Println("It's over 9000!!!!!")
    }

* Looping

    for i := 0; i < len(slice); i++ {
        frobinate(slice[i])
    }

conditional only
    
    finished := false
    for !finished {
        finished = doneYet() 
    }

infinite loop
   
    for {
        // input loop
    } 

* Switch

    switch a {
    case 1:
        fmt.Println("one") // no need to `break`!
    case 2:
        fmt.Println("two")
    case 3: fallthrough
    case 4:
        fmt.Println("three or four")
    default:
        fmt.Println("not one, two, three, or four")
    }

switch with conditions
   
    switch a {
    case a < 0:
        fmt.Println("Negative!")
    case a == 0:
        fmt.Println("Zero!")
    case a > 0:
        fmt.Println("Positive!") 
    } 

* Concurrency

* Deferring

.play defer.go

* Goroutines

.play goroutines.go

* Channels

channels are typed

    ch := make(chan int)

channels can be buffered

    ch := make(chan int, 10)
